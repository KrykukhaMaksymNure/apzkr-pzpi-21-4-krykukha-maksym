Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
     з навчальної дисципліни: «Архітектура програмного забезпечення»
     Тема роботи: Програмна система для моніторінгу стану водіїв


Студент гр. ПЗПІ-21-4	_______________ Крикуха М.Е.
							(підпис)
Керівник роботи	_______________ доц. Лещинська І.О.
							(підпис)

	Робота захищено «_» _____2024р. 
	з оцінкою ____________________
 
Комісія: 	_______________ доц. Лещинський В.О.
							(підпис)													_______________ доц. Лещинська І.О.
							(підпис)
	_______________ ст. викл. Сокорчук І.П.
							(підпис)


Харків
2024 р.
     Харківський національний університет радіоелектроніки

Факультет  комп’ютерних наук		 Кафедра  програмної інженерії		
Спеціальність  121 – Інженерія програмного забезпечення					
Курс 		3             Семестр 					6					
Навчальна дисципліна  Архітектура програмного забезпечення				
     
ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ
 
Крикухи Максима Едуардовича

1. Тема роботи: Програмна система для моніторінгу стану водіїв.
2. Термін узгодження завдання курсової роботи: «31» березня 2024 р.
3. Термін здачі студентом закінченої роботи: «10» червня 2024 р.
4. Вихідні дані до проєкту (роботи): програмна система, серверна частина, клієнтська частина, Smart Device програмний застосунок, вбудовані засоби адміністрування системи, інтернаціоналізацію, локалізацію, інтерфейс англійською та українською.	 
5. Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки    	
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень):
схема бази даних, ER-діаграма UML діаграма розгортання, UML діаграма прецедентів, UML діаграма компонентів, UML діаграма взаємодії, UML діаграма діяльності, UML діаграма станів, UML діаграма пакетів, зображення екранів («скріншоти»)										

КАЛЕНДАРНИЙ ПЛАН


№
Назва етапів курсової роботи
Термін виконання етапів роботи
Примітки
     1
Функціональна специфікація програмного проєкту
31.03.24

     2
Проєктування програмного проєкту
11.04.24

     3
Кодування програмного проєкту
30.05.24

     4
Оформлення пояснювальної записки
10.06.24

     5
Захист курсової роботи
14.06.24

     
	Дата видачі завдання: «18» лютого 2024 р.

	Керівник				_______________ доц. Лещинська І.О.
						(підпис)


	Завдання прийняв до виконання
	ст. гр. ПЗПІ-21-4					____________  Крикуха М.Е.
								(підпис)

     

РЕФЕРАТ


     Пояснювальна записка до курсової роботи: 77 с., 35 рис., 2 табл., 4 додатки, 5 джерел. 
     АВТОРИЗАЦІЯ, АНАЛІЗ ДАНИХ, БАЗА ДАНИХ, БЕЗПЕКА ДАНИХ, ВОДІЙ, КОНСОЛЬНИЙ ДОДАТОК, КОРИСТУВАЧ, МОНІТОРІНГ, ПОКАЗНИКИ ЗДОРОВ’Я, РЕАЛЬНИЙ ЧАС, СЕРЦЕБИТТЯ, СИСТЕМА СПОСТЕРЕЖЕННЯ,. СПОВІЩЕННЯ
     
     Об’єктом дослідження є індустрія моніторингу водіїв під час подорожей, зокрема, актуальне на сьогодні питання щодо організації системи відстеження серцебиття водіїв з метою оперативного реагування у випадку ДТП та забезпечення високого рівня безпеки на дорогах. 
     Метою курсової роботи є розробка системи, яка дозволяє здійснювати моніторинг водія та його серцебиття під час подорожі для оперативного реагування у випадку надзвичайних ситуацій в режимі реального часу.
     Програмний застосунок було розроблено за допомогою мови програмування Typescript, сервер бази даних оснований на Nest.js з PostgreSQL, клієнтська частина основана на технології VITE також з мовою програмування Typescript, IoT пристрій було розроблено за допомогою мови програмування Python як консольний додаток.
     Програмна система для моніторінгу стану водіїв в результаті була розроблена та складається з веб-застосунку, смарт-пристрою та серверу. 
     

ЗМІСТ


Вступ	8
1 Аналіз предметної області	9
    1.1 Бізнес-вимоги	9
        1.1.1 Бізнес-можливості	9
        1.1.2 Бізнес-цілі та критерії успіху	11
        1.1.3 Потреби клієнтів або ринку	12
        1.1.4 Бізнес-ризики	13
    1.2 Концепція рішення	14
        1.2.1 Окреслення концепції	14
        1.2.2 Головна функціональність	15
        1.2.3 Припущення та залежності	16
    1.3 Рамки та обмеження проєкту	17
        1.3.1 Рамки первинного випуску	17
        1.3.2 Рамки наступних випусків	19
        1.3.3 Обмеження та винятки	20
    1.4 Бізнес-контекст	21
        1.4.1 Профілі зацікавлених сторін	21
        1.4.2 Пріоритети проєкту	22
        1.4.3 Робоче середовище	22
2 Постановка задачі	26
3 Проєктування бази даних	27
    3.1 Побудова ER-діаграми	27
    3.2 Побудова логічної моделі бази даних на основі ER-діаграми	28
4 Архітектура програмної системи	32
    4.1 Архітектура серверної частини	32
    4.2 Архітектура IoT частини	36
    4.3 Архітектура клієнтської частини	42
5 Опис програмної системи	49
    5.1 Виклик і завантаження	49
    5.2 Призначення і логічна структура	50
    5.3 Опис програмної реалізації	51
Висновки	61
Перелік джерел посилання	62
Додаток А Результат перевірки антиплагіату	63
Додаток Б Програмний код серверної частини	64
Додаток В Програмний код IoT пристрою	70
Додаток Г Прогрмний код клієнтської частини	73

     

ВСТУП


     Одним із найважливіших аспектів сучасного життя є безпека на дорогах. Зі збільшенням кількості транспортних засобів і загальною мобільністю людей зростає і потреба в ефективному моніторингу стану водіїв під час поїздок. Втома, стрес і інші фактори можуть значно впливати на стан водія, збільшуючи ризик дорожньо-транспортних пригод.
     Сучасні технології дозволяють здійснювати моніторинг фізіологічних показників, таких як серцебиття, що дає змогу вчасно виявляти потенційні проблеми і швидко реагувати. Впровадження таких систем моніторингу є критично важливим для підвищення загального рівня безпеки на дорогах.
     Зростання кількості автомобілів на дорогах призводить до заторів і збільшення часу подорожі, а також підвищує ймовірність аварій через людський фактор. Втомлені або неуважні водії можуть стати причиною серйозних ДТП. Це особливо актуально в умовах великих міст, де інтенсивність руху і стресові ситуації є повсякденними реаліями.
     Розвиток технологій штучного інтелекту та інновацій у галузі біометричних досліджень відкриває нові можливості для створення систем моніторингу, що можуть не тільки забезпечувати безпеку водіїв, але й знижувати загальний рівень аварійності на дорогах. Використання таких систем дозволяє вчасно виявляти небезпечні зміни у фізіологічному стані водія і приймати необхідні заходи для попередження аварій.
     Метою даної курсової роботи є розробка системи, яка дозволяє здійснювати комплексний моніторинг стану водія під час подорожі, включаючи відстеження серцебиття, для оперативного реагування у випадку надзвичайних ситуацій. Система також передбачає можливість оновлення даних користувачів, які забезпечують комфорт і безпеку під час поїздок.

1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
     1.1 Бізнес-вимоги
     1.1.1 Бізнес-можливості
     
     
     Ринок систем моніторингу водіїв переживає стрімке зростання, зумовлене підвищенням рівня обізнаності про безпеку дорожнього руху та впровадженням передових систем допомоги водієві (ADAS) у транспортних засобах. На цьому ринку вже з'явилося кілька конкурентів, кожен з яких пропонує унікальні послуги зі своїми сильними та слабкими сторонами.
     1. Samsara - надає комплексну платформу для управління автопарком, яка включає в себе функції моніторингу водіїв, а також GPS-трекінг, діагностику транспортних засобів та інструменти для дотримання нормативних вимог.
     Сильні сторони:
* інтегроване рішення: пропонує комплексне рішення для управління автопарком, ключовим компонентом якого є моніторинг водіїв;
* дані в режимі реального часу: надає дані GPS-трекінгу та телематичні дані в режимі реального часу для повної видимості автопарку;
* аналітика на основі штучного інтелекту: використовує штучний інтелект для аналізу поведінки водіїв і пропонує інструменти для підвищення безпеки та ефективності.
     Недоліки:
* орієнтований на великі автопарки: переважно обслуговує великі автопарки, потенційно менш придатний для індивідуальних водіїв або малого бізнесу;
* вартість: може бути дорожчим порівняно з деякими конкурентами через свої комплексні функції.
     2. Lytx - провідний постачальник відеотелематичних рішень, що спеціалізується на безпеці водіїв та управлінні ризиками. Їх система використовує камери та датчики для фіксації подій під час водіння та надання інформації про поведінку водія.
     Сильні сторони:
* лідер галузі: великий досвід і міцна репутація в галузі безпеки водіїв;
* програми управління ризиками: надає комплексні програми управління ризиками для водіїв, щоб допомогти автопаркам підвищити безпеку та зменшити відповідальність.
     Недоліки:
* вартість: може бути дорогим для невеликих автопарків або окремих водіїв через передові відео-технології та послуги;
* занепокоєння щодо конфіденційності: використання відеозапису може викликати занепокоєння щодо конфіденційності у деяких водіїв та організацій.
     3. Nauto - фокусується на аналізі поведінки водія на основі штучного інтелекту та навчанні в режимі реального часу. Їх система використовує комбінацію камер і датчиків для виявлення відволікання уваги за кермом, сонливості та іншої ризикованої поведінки.
     Сильні сторони:
* аналітика на основі штучного інтелекту: використовує передові алгоритми штучного інтелекту для точного аналізу поведінки водія в режимі реального часу;
* запобігання відволікання: пропонує функції, спеціально розроблені для виявлення та запобігання інцидентів, пов'язаних з відволіканням уваги за кермом;
* зосередженість на приватності: підкреслює конфіденційність водія, анонімізуючи дані та забезпечуючи прозорість у практиках збору даних.
     Слабкі сторони:
* обмежене управління автопарком: пропонує менше функцій управління автопарком порівняно з такими конкурентами, як Samsara;
* сумісність з транспортними засобами: може бути не сумісним з усіма типами транспортних засобів або умовами водіння.
     Хоча ці конкуренти пропонують цінні рішення, мій додаток системи моніторингу водіїв має на меті диференціювати себе:
* доступністю: орієнтована на ширше коло користувачів, включаючи індивідуальних водіїв та малий бізнес, з економічно ефективним рішенням;
* підхід, орієнтований на конфіденційність: пріоритет конфіденційності водіїв через анонімізацію даних, прозорість та контроль користувача над даними;
* зручний інтерфейс;
* інтеграція передових технологій: використання новітніх технологій штучного інтелекту та сенсорів для точного та надійного моніторингу водіїв. 
     
     
     1.1.2 Бізнес-цілі та критерії успіху
     
     
     БЦ-1: знизити аварійність, пов'язану з втомою водія, на 20%. Ця мета спрямована на значне зменшення кількості аварій, спричинених сонливим водінням. Система досягне цього завдяки ефективному виявленню втоми водія та своєчасному попередженню, щоб запобігти аваріям до того, як вони трапляться.
     БЦ-2: підвищити пильність водія та зменшити відволікання на 15%. Ця мета зосереджена на підвищенні обізнаності водіїв та мінімізації відволікань під час водіння. Система досягне цього шляхом моніторингу поведінки водія та надання зворотного зв'язку для заохочення до безпечного водіння.
     БЦ-3: домогтися прийняття системи 10000 користувачами/компаніями протягом першого року. Ця ціль спрямована на створення потужної бази користувачів системи протягом першого року роботи. Цього буде досягнуто завдяки ефективному маркетингу, партнерству та демонстрації переваг системи як окремим водіям, так і компаніям, що займаються управлінням автопарками.
     КУ-1: досягти рівня задоволеності клієнтів не менше 90%. Цей критерій успіху підкреслює важливість задоволення користувачів системою. Високий рівень задоволеності користувачів буде досягнутий, якщо система буде зручною, надійною та надаватиме цінні функції, що відповідають потребам користувачів.
     КУ-2: забезпечити партнерство щонайменше з 5 найбільшими компаніями з управління автопарками. Цей критерій фокусується на встановленні стратегічного партнерства з ключовими гравцями в галузі управління автопарками. Ці партнерства матимуть вирішальне значення для розширення охоплення системи та сприяння її впровадженню у великих автопарках.
     КУ-3: досягти прибутковості протягом 3 років. Цей критерій підкреслює важливість фінансової стійкості проекту. Досягнення прибутковості протягом трьох років забезпечить довгострокову життєздатність системи та дозволить продовжувати розвиток і вдосконалення.
     
     
     1.1.3 Потреби клієнтів або ринку
     
     
     В моєму додатку системи є два основні види користувачів: бізнес та його клієнти.
     Потреби бізнесу:
* підвищення безпеки водіїв, керівники автопарків відповідають за безпеку своїх водіїв і прагнуть мінімізувати аварійність. Система повинна допомогти виявити та усунути ризиковану поведінку водія, таку як сонливість, відволікання уваги та перевищення швидкості;
* зменшити витрати на аварії, аварії можуть дорого коштувати автотранспортним компаніям як з точки зору пошкодження транспортних засобів, так і з точки зору страхових премій. Система повинна допомогти знизити рівень аварійності, що призведе до економії коштів;
* підвищення операційної ефективності, система повинна надавати дані та інформацію, які допоможуть менеджерам автопарку оптимізувати маршрути, графіки та роботу водіїв.
     Потреби клієнтів бізнесу:
* залишатися уважними та безпечними за кермом, водії хочуть уникнути аварій та забезпечити власну безпеку на дорозі. Система повинна надавати чіткі та своєчасні попередження при виявленні сонливості або відволікання уваги;
* покращити водійські звички, система повинна надавати зворотний зв'язок та інформацію, яка допомагає водіям виявляти та виправляти погані водійські звички;
* зменшити витрати на страхування, деякі страхові компанії пропонують знижки для водіїв, які використовують системи моніторингу.
     
     
     1.1.4 Бізнес-ризики
     
     
     Ризики:
* ринок систем моніторингу водіїв стає все більш конкурентним, на ньому з'являються нові учасники та вже відомі гравці, які пропонують різноманітні рішення;
* збір та використання даних викликає занепокоєння водіїв щодо конфіденційності та може призвести до регуляторних проблем;
* водії та компанії можуть чинити опір впровадженню нових технологій або сприймати їх як нав'язливі.
     Можливі дії:
* вдосконалення маркетингових стратегій;
* співпраця з ключовими гравцями ринку;
* проведення пілотних запусків та тестувань перед повним впровадженням.


     1.2 Концепція рішення
     1.2.1 Окреслення концепції
     
     
     Основна ідея системи моніторингу водіїв полягає в тому, щоб значно підвищити безпеку дорожнього руху шляхом постійного моніторингу пильності та поведінки водіїв, надання зворотного зв'язку в режимі реального часу та втручання для запобігання аваріям, спричиненим сонливістю або відволіканням уваги.
     Ця система використовуватиме передові технології, система дає можливість водіям залишатися зосередженими та приймати безпечніші рішення на дорозі.
     Система моніторингу водіїв має на меті сприяти підвищенню культури безпеки в транспортній галузі, що в кінцевому підсумку призведе до значного зменшення кількості дорожньо-транспортних пригод та порятунку життів. 
     Переваги для користувачів:
* підвищення безпеки: система допомагає запобігти аваріям, попереджаючи водіїв про сонливість та відволікання, що потенційно рятує життя та зменшує травматизм;
* підвищення обізнаності водіїв: водії отримують цінну інформацію про власну поведінку та можуть визначити сфери для вдосконалення, що призводить до формування безпечніших звичок водіння;
* зниження витрат: запобігаючи аваріям, система може допомогти зменшити витрати, пов'язані з пошкодженням транспортного засобу, страховими преміями та втратою продуктивності;
* підвищення операційної ефективності: менеджери автопарків можуть використовувати систему для оптимізації маршрутів, розкладів і роботи водіїв, що призводить до підвищення ефективності та економії коштів;
* душевний спокій: водії та менеджери автопарку можуть бути більш спокійними, знаючи, що у них є система, яка допомагає забезпечити безпеку на дорозі.
     
     
     1.2.2 Головна функціональність
     
     
     ГФ-1: моніторинг водіїв.
     ГФ-2: фізіологічний моніторинг - інтеграція з натільними пристроями для моніторингу фізіологічних показників, таких як частота серцевих скорочень, надаючи додаткову інформацію про пильність і рівень стресу водія.
     ГФ-3: система оповіщення - надавати настроювані звукові попередження, такі як звукові сигнали, дзвінки або голосові підказки, щоб попередити водія, коли виявлено сонливість або відволікання уваги.
     ГФ-4: візуальні попередження - відображення візуальних попереджень на інтерфейсі системи або через підключені пристрої, наприклад, миготливі лампочки або сповіщення на приладовій панелі.
     ГФ-5: звітність та аналітика про роботу водія: - детальні звіти про поведінку водія, включаючи такі показники, як сонливість, інциденти, що відволікають увагу.
     ГФ-6: профілі користувачів – можливість створювати персоналізовані профілі.
     ГФ-7: захист конфіденційності – шифрування даних впровадженням надійними протоколи шифрування для захисту даних водіїв як під час руху, так і на зупинках. Безпечне зберігання: Безпечне зберігання даних на серверах з обмеженим доступом і регулярними перевірками безпеки.
     ГФ-8: можливість дистанційного керування системою через веб-інтерфейс: Користувачі можуть керувати системою за допомогою веб-інтерфейсу.
     ГФ-9: багатомовний інтерфейс: Користувачі можуть користуватися додатком англійською й українською мовами.
     
     
     1.2.3 Припущення та залежності
     
     
     П-1: технологічний прогрес - система передбачає постійний розвиток сенсорів, камер і технологій штучного інтелекту для підвищення точності та надійності.
     П-2: система матиме змогу зберігати велику кількість інформації в базі даних без проблем з обробкою.
     П-3: наявне стійке Інтернет-з'єднання для забезпечення обміну даними.
     З-1: доступність обладнання - система залежить від наявності надійних і доступних датчиків, камер і процесорів для збору та аналізу даних про поведінку водіїв.
     З-2: розробка програмного забезпечення - система залежить від успішної розробки та впровадження складних програмних алгоритмів для аналізу даних, генерації сповіщень та звітності.
     З-3 інфраструктура зв'язку - система залежить від надійного підключення до Інтернету для передачі даних, хмарної обробки та комунікації в режимі реального часу.
     
     
     1.3 Рамки та обмеження проєкту
     1.3.1 Рамки первинного випуску
     
     
     Серверна частина повинна включати:
* реєстрацію та авторизацію користувачів: реалізація системи користувачів та механізмів входу з підтримкою ролей та прав доступу;
* обробка та аналіз даних: розробка алгоритмів і моделей для обробки даних з датчиків і камер, аналізу поведінки водія та виявлення ознак сонливості або відволікання уваги;
* сповіщення користувачів: впровадити систему генерації сповіщень у реальному часі на основі виявлених ризиків;
* захист даних: захист особистих даних;
* адміністрування системи: управління користувачами системи, управління  даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами.
     IoT частина повинна включати:
* інтеграція датчиків: інтегрування датчиків та камер в транспортний засіб для збору даних про поведінку водія, включаючи рухи очей, положення голови та вираз обличчя;
* передача даних: створення безпечного і надійного канал зв'язку для передачі даних з бортових пристроїв на сервер для обробки та аналізу;
* отримання сповіщень: система для отримання сповіщень водієві в реальному часі.
     Клієнтська частина повинна включати:
* реєстрація та вхід адміністратора: сторінки авторизації та реєстрації;
* панель адміністратора: дає управління користувачами системи, управління даними системи, дозволяє адміністраторам налаштовувати системні параметри, такі як пороги сповіщень, налаштування сповіщень.
     Мобільна частина повинна включати:
* реєстрація та вхід для користувачів: впровадження зручного процесу реєстрації та входу для водіїв, щоб вони могли отримати доступ до програми та персоналізувати свої налаштування;
* моніторинг водіїв: зворотній зв'язок з водіями в режимі реального часу щодо їхньої пильності та поведінки, включаючи візуальні індикатори та сповіщення;
* локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання, англійських  та американських систем мір, порядку сортування текстових значень, різного напряму введення тексту;
* персоналізовані налаштування: дозволяє водіям налаштовувати пороги спрацьовування сповіщень і параметри сповіщень




     1.3.2 Рамки наступних випусків


     Серверна частина може включати:
* аналітика та статистика: реалізація аналітики, надання звітів про стан для користувачів та адміністраторів;
* розширений аналіз поведінки водія: розробка більш складних алгоритмів для аналізу поведінки водія, включаючи виявлення втоми, розпізнавання емоційного стану та прогнозування ризикованих ситуацій під час водіння;
* інтеграція машинного навчання: впровадження моделі машинного навчання для постійного підвищення точності та ефективності моніторингу водіїв і генерації попереджень;
* інтеграція із зовнішніми системами: інтеграція з іншими відповідними системами, такими як телематика транспортних засобів, погодні дані та інформація про дорожній рух, щоб отримати більш цілісне уявлення про умови та ризики водіння.
     IoT частина може включати:
* розширена інтеграція датчиків: інтегрування додаткових датчиків, такі як ті, що вимірюють частоту серцевих скорочень, провідність шкіри та активність мозкових хвиль, щоб забезпечити більш повне розуміння фізіології та пильності водія;
* ідентифікація водія: впровадження системи ідентифікації водія для персоналізації налаштувань і відстеження індивідуальних показників роботи водія.
     Клієнтська частина може включати:
* предиктивна аналітика: впровадження інструментів предиктивної аналітики для виявлення потенційних ризиків та проактивного вирішення проблем безпеки;
* наставництво та навчання водіїв: розробка платформи для проведення персоналізованих тренінгів та навчальних програм для водіїв на основі їхніх індивідуальних потреб та даних про ефективність роботи;
* гейміфікація: впровадження елементів гейміфікації для мотивації водіїв та заохочення до безпечного водіння.
     Мобільна частина може включати:
* персоналізоване навчання: надання водіям персоналізоване навчання та зворотній зв'язок на основі їхніх даних про водіння та тенденцій продуктивності;
* функції спільноти: розроблення функції спільноти, щоб об'єднувати водіїв, ділитися досвідом та сприяти розвитку культури безпеки;
* винагороди та заохочення: впровадження систему винагород та заохочень, щоб мотивувати водіїв та заохочувати до безпечного водіння.
     
     
     1.3.3 Обмеження та винятки
     
     
     Залежність від електроенергії: однією з частин системи є IoT пристрої, що знаходяться в столах та передають дані на сервер. Без електроенергії їх функціонування неможливе.
     Підключення до мережі Інтернет: для забезпечення зв’язку з системою необхідне підключення до мережі Інтернет.
     На точність системи можуть впливати фактори навколишнього середовища та індивідуальні особливості.
     
     
     1.4 Бізнес-контекст
     1.4.1 Профілі зацікавлених сторін
     
     
     Профілі зацікавлених сторін проекту наведені в таблиці 1.1.
     
     Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона
Головна цінність
Ставлення
Головний інтерес
Обмеження
     Бізнес
Можливість легкого та швидкого впровадження системи автоматизації 
Зацікавленість, очікування програмної системи що дешево задовольнить потреби 
Покращення безпеки на дорозі, зменшення ДТП
Доступ до мережі Інтернету
     Звичайні користувачі
Легкість користування системою, можливість отримувати усю необхідну інформацію у режимі реального часу
Зацікавленість, проте можливе покинення додатку у зв’язку з незадоволеними очікуваннями
Ідея покращення безпеки водіїв, заощадження коштів
Доступ до мережі Інтернет
     Розробник проєкту
Можливість гарно заробити та в подальшому розширити компанію
Зацікавленість в успіху проекта та задоволенні цільової аудиторії
Заробіток, репутація
Правові обмеження, нестача досвіду, грошові обмеження, доступ до мережі Інтернет
     Інвестори
Отримання прибутку
Зацікавленість в успіху проекта 
Заробіток
Грошові обмеження
          
     1.4.2 Пріоритети проєкту
     
     
     Пріоритети проєкту наведені в таблиці 1.2.
     
     Таблиця 1.2 – Пріоритети проєкту
Показник
Виконання (етапи)
Обмеження (граничні значення)
Ступінь свободи (допустимий діапазон)
     План робіт
продукт має бути випущеним до 10.06.2024

можливе відхилення від графіку на 1-2 місяці
     Функціональність


90% функціоналу має працювати на релізі 1.0
     Якість


у випуску 1.0 повинні пройти 100% тестувань
     Персонал

максимальний розмір команди – один розробник та адміністратор
Персонал
     Ціна

50000 гривень
допустиме відхилення на 10%
     	
     
     1.4.3 Робоче середовище
     
     
     Було обрано PostgreSQL як основну базу даних через її надійні функції, зокрема:
* надійність та цілісність даних: PostgreSQL [1] відповідає стандартам ACID (атомарність, узгодженість, ізоляція, довговічність), забезпечуючи цілісність та узгодженість даних навіть у випадку системних збоїв;
* безпека: PostgreSQL надає розширені функції безпеки, такі як контроль доступу на основі ролей, шифрування даних та можливості аудиту для захисту конфіденційних даних водіїв;
* масштабованість: PostgreSQL може обробляти великі набори даних і велику кількість одночасних користувачів, що робить її придатною для потенційного зростання системи моніторингу водіїв.
     Було обрано TypeScript з фреймворком Nest.js для розробки серверної частини завдяки наступним перевагам:
* безпека типів: статична типізація TypeScript допомагає запобігти помилкам і покращує супроводжуваність коду, що сприяє підвищенню надійності системи;
* модульна архітектура: Nest.js підтримує модульну архітектуру, що робить кодову базу простішою в управлінні та масштабуванні по мірі зростання системи;
* продуктивність та масштабованість: Nest.js побудований на основі Node.js, відомого своєю високою продуктивністю та масштабованістю, що гарантує, що серверна частина може впоратися зі збільшенням робочими навантаженнями;
* функції безпеки: Nest.js надає вбудовані функції безпеки, такі як автентифікація, авторизація та перевірка вводу, які будуть додатково покращені за допомогою додаткових заходів безпеки.
     Було обрано Next.js з TypeScript для розробки клієнтської частини через його:
* серверне відображення (SSR): Next.js забезпечує SSR, покращуючи продуктивність та SEO-оптимізацію веб-панелі;
* архітектура на основі компонентів:React.js [3] підтримує архітектуру на основі компонентів, що робить кодову базу клієнтської частини модульною та легшою в обслуговуванні;
* функції безпеки: Next.js має вбудований захист від поширених веб-вразливостей, таких як XSS та Clickjacking атаки, що підвищує безпеку користувацького інтерфейсу;
* інтеграція з TypeScript: використання TypeScript з Next.js забезпечує безпеку типів і покращує якість коду, сприяючи підвищенню надійності і ремонтопридатності інтерфейсу.
     Було обрано консольний додаток на Python для розробки та тестування основного компонента системи. Це дозволяє швидко створювати прототипи та виконувати ітерації перед розгортанням на реальних пристроях.
     Було обрано Kotlin для розробки мобільних додатків через:
* сучасність та ефективність: Python є сучасною мовою програмування, відомою своєю лаконічністю та ефективністю, що сприяє швидкому розробленню та тестуванню програмних рішень;
* сумісність з різними платформами: Python добре інтегрується з різними операційними системами та платформами, що робить його ідеальним вибором для розробки кросплатформних додатків;
* оптимізація продуктивності: Python забезпечує високу продуктивність розробки завдяки великій кількості бібліотек і фреймворків, що дозволяють швидко створювати складні додатки.
     Буде впроваджено для захисту даних:
* Cross-Origin Resource Sharing (CORS) для контролю доступу до ресурсів різного походження, запобігаючи несанкціонованому доступу та витоку даних;
* Nest.js Guards: буде використано Nest.js Guards для детального контролю доступу та авторизації у внутрішньому API;
* захист від XSS та Clickjacking: буде використано вбудований захист Next.js від XSS і Clickjacking атак для захисту інтерфейсу користувача.

2 ПОСТАНОВКА ЗАДАЧІ
     

     Відповідно до проведеного аналізу предметної області, основною задачею курсової роботи стало розроблення програмної системи для моніторингу стану водіїв під час їхніх поїздок.
     База даних повинна включати інформацію про: водіїв, записи серцебиття, тривоги, слідкуючих, нещасні випадки, машини.
     Для клієнта має бути реалізований такий функціонал:
* реєстрація та вхід в систему;
* додавання своїх власних авто до системи;
* перегляд серцебиття водія;
* перегляд нещасних випадків що коїлись;
* перегляд сповіщень;
* обирати вільного водія для початку або зупиненню слідкування за його серцебиттям;
* редагування власного профілю.
     Для адміністратора системи має бути реалізований такий функціонал:
* реєстрація та вхід в систему;
* перегляд, редагування, видалення даних про користувачів;
* перегляд, редагування, видалення даних про нещасні випадки;
* перегляд, редагування даних про автомобілі;
* перегляд, редагування, видалення серцебиття водія та водіїв ;
* експорт та імпорт даних системи.
     Розроблюваний додаток повинен мати локалізацію та інтернаціоналізацію для кращого використовування користувача нашого продукту, потрібно підтримувати різні кодові таблиці символів, універсальний та локальний час, фільтрація та сортування тексту, обчислення формату дати та часу.

3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ
     3.1 Побудова ER-діаграми
     
     
     Для проектування бази даних, попередньо була розроблена ER діаграма (див. рис. 3.1). Вона складається з 6 таблиць: машини, водії, спостерігачі, серцебиття, сповіщення, нещасний випадок або скорочено випадок.



Рисунок 3.1 – ER-діаграма бази даних системи «CareDrive»

     Сутність Слідкувачі – це сутність, яка містить інформацію про тих хто слідкує за водіями, і пов’язана зв’язком «один-до-одного» із сутністю Водії.
     Сутність Випадки – це сутність, що містить інформацію нещасні випадки водія, і пов’язана зв’язком «один-до-одного» із сутністю Сповіщення.
     Сутність Сповіщення – це сутність, що містить інформацію нещасні випадки водія, і пов’язана зв’язком «один-до-одного» із сутністю Випадки та зв’язком «багато-до-одного» із сутністю Водії.
     Сутність Серцебиття – це сутність, що містить інформацію про серцебиття водія, і пов’язана зв’язком «багато-до-одного» із сутністю Водії.
     Сутність Машини – це сутність, що містить інформацію про власні машини водія, і пов’язана зв’язком «багато-до-одного» із сутністю Водії.
     Сутність Водії – це сутність, що містить інформацію про водіїв, і пов’язана із сутностями Машини, Серцебиття та Сповіщення зв’язком «один-до-багатьох» та із сутністю Слідкувачі зв’язком «один-до-одного».
     
     
     3.2 Побудова логічної моделі бази даних на основі ER-діаграми
     
     
     Отже, у логічній моделі бази даних будуть представлені такі сутності:
* водії (Drivers);
* слідкуючі (Watchers);
* машини (Car);
* серцебиття (Heartbeat);
* сповіщення (Alert);
* випадки (Accident).
     Створимо таблицю водіїв (Drivers). Вона буде містити у собі такі атрибути: driverId (первинний ключ), driverName, driverSurname, createdAt, updatedAt, email, phone, password, averageMontlyHeartbeat, city, watcherId (зовнішній ключ для зв’язку «один-до-одного» з таблицею Watchers), carId (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Car), alertId (зовнішній ключ для зв’язку «багато-до-одного» з таблицею Alerts).
     Перевіримо таблицю Drivers на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю карток слідкувачей (Watchers). Вона буде містити у собі такі атрибути: watcherId (первинний ключ), watcherName, watcherSurname, createdAt, updatedAt, email, phone, password, role, isTaken.
     Перевіримо таблицю Watchers на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю Машин (Cars). Вона буде містити у собі такі атрибути: carId (первинний ключ), model, year, registationCity.
     Перевіримо таблицю Cars на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю серцебиття (Heartbeats). Вона буде містити у собі такі атрибути: heartbeatId (первинний ключ), count, description, createdAt.
     Перевіримо таблицю Heartbeats на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю сповіщень (Alerts). Вона буде містити у собі такі атрибути: alertId (первинний ключ), reason, createdAt, accidentId (зовнішній ключ для зв’язку «один-до-одного» з таблицею Accidents). 
     Перевіримо таблицю Alerts на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     Створимо таблицю випадки (Accidents). Вона буде містити у собі такі атрибути: accidentId (первинний ключ), reason, place, description. 
     Перевіримо таблицю на відповідність нормалізації:
* усі атрибути атомарні: містять лише одне значення, а не множину;
* відсутність повторюваності даних;
* усі неключові атрибути залежать від первинного ключа.
     Отже, таблиця задовольняє першій, другій і третій нормальній формі.
     За результатами проектування таблиць та зв’язків майбутньої бази даних, отримано її логічну схему (див. рис. 3.2).


Рисунок 3.2 – Логічна схема бази даних системи «CareDrive»

     Оскільки всі таблиці в наведеній логічній схемі бази даних знаходяться в третій нормальній формі, то можна зробити висновок, що отримана база даних знаходиться в третій нормальній формі.
     

4 АРХІТЕКТУРА ПРОГРАМНОЇ СИСТЕМИ
     4.1 Архітектура серверної частини
     
     
     В розробленій системі «CareDrive» існує 2 типи акторів: клієнт та спостерігач.
	Основними можливостями клієнта є: можливість обирання вільного спостерігача при поїздці машиною, для того щоб при будь якому випадку спостерігач побачив змінення серцебиття клієнта та зміг швидко відреагувати на ситуацію; можливість перегляду інформації про власні машини; можливість перегляду клієнтом інформації стосовно його серцебиття; можливість перегляду інформації стосовно нещасних випадків, які сталися.
	Основними можливостями спостерігача є: можливість увійти в систему як адміністратор; можливість створювати резервні копії даних системи та їх імпорт до системи; можливість переглядати та керувати користувачами системи.
	Взаємодію кожної ролі користувачів з системою представлено на діаграмі прецедентів (див рис. 4.1). Таким чином за допомогою діаграми прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.


Рисунок 4.1 – Діаграма прецедентів серверної частини програмної системи «CareDrive»
     
     Розроблена серверна частина була написана за допомогою технології Nest.js на мові програмування Typescript, за допомогою якої можна швидко, продуктивно та надійно розроблювати проекті завдяки наданої типізації.
     Для запису та читання даних було використано базу даних PostgreSQL, доступ до якої відбувається за допомоги PrismaORM, що надає зручний функціонал для обробки та взаємодії за базою даних.
     Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.2).
     

Рисунок 4.2 – Діаграма розгортання серверної частини програмної системи «CareDrive»
     
     Для демонстрації та тестування було обрано Postman, який дозволяє зручно тестувати API. Також для кращої конфіденційності було використано захищений протокол HTTPS, який захищає дані під час передачі.
     Для автентифікації та авторизації було використано nestjs/jwt, бо це стандартизований спосіб безпечної передачі даних між двома сторонами, де міститься інформація закодована у JSON.
     Для маршрутизації запитів було використано API контролери, які допомогли розділити програму на логічні компоненти, кожен з яких був відповідальним за свою обробку певного запиту або дій користувача.
     Для розробки серверного застосунку було використано Clean Architecture [4], розподілом на моделі, сервіси та контролери.
     Архітектура серверної частини застосунка представлена на діаграмі пакетів (див. рис. 4.3).
     Система складається з 5 компонентів: сервер, веб-додаток, база даних, мобільний застосунок
     
     
Рисунок 4.3 – Діаграма пакетів серверної частини програмної системи «CareDrive»
     
     Приклади частин коду серверного застосунка представлено у додатку Б.
     Таким чином, було визначено технології й архітектуру серверної частини програмної системи.
     
     
     
     
     
     4.2 Архітектура IoT частини
     
     
     Користувачами Iot частини розробленої системи є 2 типи акторів: адміністратор та сам Iot пристрій.
     Основними можливостями адміністратора є: можливість налаштування розумного пристрою; отримувати інформацію про поточне серцебиття водія, за допомогою чого адміністратор в якийсь нещасний випадок може швидко відреагувати на ситуацію та допомогти водію.
     Основними можливостями пристрою є: можливість регулярної надсилання або отримування статусу сесії водія; авторизація водія як власника цього пристрою та занесення це в базу даних.
     Взаємодію кожної ролі користувачів з Iot частиною системи представлено на діаграмі прецедентів (див. рис. 4.4).
     

Рисунок 4.4 – Діаграма прецедентів IoT частини програмної системи «CareDrive»

     Для демонстрації функціональних можливостей розумного пристрою системи моніторингу водіїв реалізовано на мові Python. Програмна реалізація буде максимально наближена до пристроїв RaspberryPi [5], які можуть запускати програми на Python. Причини чому було обрано саме Python:
* простота та зручність для читання - зрозумілий синтаксис Python полегшує розробку та підтримку коду, що має вирішальне значення для надійної та стійкої системи;
* широкі бібліотеки - Python пропонує численні бібліотеки для таких завдань, як збір, обробка, аналіз та передача даних. Це позбавляє від необхідності писати все з нуля, заощаджуючи час для розробки.
     В програмному забезпечені дані надсилаються за допомогою бібліотеку requests, у форматі JSON.
     Програмне забезпечення структуроване на модулі, кожен з яких відповідає за певну функціональність (приклади коду див. додат. В):
* iot.py – модуль в якому можна створити новий розумний пристрій для подальшої праці програмного коду;
* Heartbeat.py – цей модуль, за допомогою алгоритмів для виявлення порушень  з серцебиттям, слідкує за водієм, щоб адміністратор у разі нещасного випадку міг відреагувати та допомогти водію;
* Auth.py – цей модуль керує процесом автентифікації водія, забезпечуючи безпечний зв'язок з сервером;
* configuration.py - цей модуль, створений для того щоб швидко отримувати та змінювати конфігурації системи;
     Session.py - цей модуль керує даними сеансу водія, зокрема часом початку та завершення, зібраними показаннями датчиків та будь-якими виявленими подіями
     Для написання програмної реалізації Iot пристрою було обрано мову Python, його було обрано за простоту використання, великі бібліотеки та придатність для обробки та аналізу даних. 
     Для створення HTTPS запитів та комунікації з сервером було використано бібліотеку requests, також є SSLсертифікати за допомогою яких і підтримується надсилання запитів по цьому протоколу. 
     Для шифрування та розшифрування даних у форматі JSON було використано однойменну бібліотеку json.
     Сама програма складається з 6 класів. 
     Для більш детальної візуалізації архітектури та використаних технологій було розроблено діаграму пакетів (див. рис. 4.5).
     

Рисунок 4.5 – Діаграма пакетів IoT частини програмної системи «CareDrive»

     Для демонстрації взаємодії пристрою з сервером також було створено діаграму взаємодії (див. рис. 4.6) і діаграму діяльності (див.рис. 4.7).
     
Рисунок 4.6 – Діаграма станів IoT частини програмної системи «CareDrive»
     
     Наведена діаграма діяльності візуально представляє робочий процес розумного пристрою.
     Початковий крок:
* створення нового пристрою IoT - процес починається зі створення та ініціалізації нового пристрою IoT. Цей крок включає присвоєння унікального ідентифікатора, налаштування параметрів і встановлення комунікаційних можливостей.
     Основний потік:
* авторизація - водій проходить процес авторизації, який включає аутентифікацію на центральному сервері;
* приєднання IoT-пристрою до драйвера - після успішної авторизації водія, створений раніше пристрій приєднується в базі даних до цього водія, що дозволяє збирати та відстежувати персоналізовані дані;
* перевірити, чи розпочався сеанс водія - пристрій перевіряє, чи сеанс водія наразі активний. Це включає отримання сигналу від водія, виявлення руху транспортного засобу або інші тригери.
     Точка прийняття рішення та розгалуження.
     Чи сеанс розпочато? 
     Точка прийняття рішення досягається на основі того, чи активний сеанс водія:
* так - якщо сеанс триває, пристрій переходить до наступного кроку;
* ні - якщо сеанс не активний, пристрій входить у цикл, повторюючи перевірку на початок сеансу.
     Активний потік сеансу.
* перевірити, чи завершився сеанс драйвера - пристрій періодично перевіряє наявність ознак завершення сеансу драйвера. Це може бути введення даних водієм, виявлення бездіяльності або досягнення пункту призначення.
     Точка прийняття рішення та розгалуження.
     Сеанс завершено? 
     Інша точка прийняття рішення оцінює, чи сеанс завершено.
* так - якщо сеанс завершено, пристрій виконує крок "Надіслати дані сеансу водія";
* ні - якщо сеанс все ще активний, пристрій повертається до попереднього кроку і продовжує моніторинг завершення сеансу.
     Останній крок.
* надіслати дані сеансу водія - після завершення сеансу водія пристрій передає зібрані дані на центральний сервер. Ці дані включають тривалість сеансу, показання датчиків і будь-які виявлені події.
     Приклади коду програмної реалізації IoT частини системи представлено у додатку В
     
      Рисунок 4.7 - Діаграма діяльності Iot частини системи «CareDrive»
     
     4.3 Архітектура клієнтської частини
     
     
     Користувачами клієнтської системи для спостереження за станом водіїв є 2 типи акторів: адміністратор та клієнт.
     Основними потребами адміністратора системи є: можливість керування системою, а саме експортувати базу даних та імпортувати базу даних в систему; можливість створювати нових водіїв та редагувати і видаляти  існуючих водіїв; можливість переглядати автомобілі водіїв, також редагувати або видаляти існуючі дані про авто; можливість створювати нових користувачів системи для того щоб слідкувати за водіями під час подорожі, редагувати та видаляти користувачів; можливість створювати, редагувати та видаляти нещасні випадки які трапляються.
     Основними потребами клієнта системи а саме спостерігача є: переглядати статистку про серцебиття водія; переглядати статистику серцебиття усіх водіїв; переглядати вільних водіїв які не були обрані для спостерігання, щоб починати або закінчувати спостерігання за серцебиттям водія.
     Взаємодія кожної ролі користувачів з клієнтської частини системи можна побачити на діаграмі прецедентів (див. рис. 4.8).
     Таким чином, на діаграмі прецедентів було визначено функціональні потреби та взаємодію різних типів користувачів із системою.
Рисунок 4.8 – Діаграма прецедентів клієнтської частини програмної системи «CareDrive»
     
     Для створення клієнтської частини системи було обрано мову програмування TypeScript з використанням технології React, що забезпечує високу швидкість розробки та зручність у використанні завдяки статичній типізації та компонентному підходу.
     Для реалізації клієнтських елементів були використані бібліотеки Material UI, які пропонують готові та стилізовані компоненти для швидкої та зручної розробки візуально привабливого веб-додатку.
     Для впровадження локалізації інтерфейсу застосовано бібліотеку i18next, що дозволяє легко та ефективно створювати багатомовний інтерфейс та забезпечує зручний механізм перекладу текстових рядків.
     Для реалізації навігації по сайту використовується бібліотека react-router-dom, яка надає зручні та потужні інструменти для створення динамічної навігації та управління маршрутами веб-додатку.
     Для виконання асинхронних запитів до сервера була використана бібліотека axios, яка забезпечує зручний та потужний інтерфейс для роботи з HTTP-запитами та дозволяє легко обробляти відповіді від сервера.
     Для розгортання сервера був використаний інструмент побудови Vite [2], який пропонує швидкий та ефективний спосіб розгортання веб-додатків, дозволяючи легко налаштовувати середовище розробки та підтримуючи автоматичне оновлення в реальному часі.
     Візуалізація усіх використаних пакетів розроблена на діаграмі пакетів (див. рис. 4.9).
     

Рисунок 4.9 – Діаграма пакетів клієнтської частини програмної системи «CareDrive»
     
     Клієнтську частину розроблено з використанням архітектури Feature-Sliced, яка передбачає структурування проекту за допомогою шарів. Ці шари містять зрізи, а ті, в свою чергу, включають сегменти. Шари представлені як каталоги верхнього рівня додатку. У проєкті визначено сім шарів: app, pages, components, features, interfaces, context та hooks.
     Шар app містить основну конфігурацію додатку. Шар pages включає сторінки сайту. Шар components складається з різноманітних інтерфейсних компонентів, які можуть бути повторно використані. Шар features відповідає за функціональність додатку та визначає дії, доступні користувачу. Шар interfaces містить інтерфейси моделей, які використовуються для обміну даними з сервером та їхнього відображення на сторінках. Шар context визначає об’єкти контексту, що забезпечують передачу даних іншим компонентам, відповідним контексту. Шар hooks включає об’єкти хуків, які дозволяють компонентам отримувати доступ до станів системи.
     Більш детальна візуалізація архітектури розробленої програмної системи зображена на діаграмі компонентів (див. рис. 4.10).
     Початок використовування додатку це введення даних профілю, реєстрація або, якщо є існуючий профіль то авторизація. Після проходження першого етапу шлях користувача розподіляється на два путі, відповідно до ролі користувача.
     Якщо користувач – адміністратор, то він може використовувати панель адміністратора для управління всією системою. В нього є можливість імпортувати або експортувати базу даних системи; можливість переглядати користувачів системи а саме спостерігачів, та редагувати їх дані; можливість переглядати дані про водіїв, та редагувати їх дані; можливість переглядати машини водіїв, та редагувати ці дані; можливість переглядати усі нещасні випадки що скоїлись та редагувати ці дані.
     Та звичайний користувач системи – спостерігач. Він має можливість переглянути статистику серцебиття обраного водія; можливість переглядати статистику всіх водіїв; можливість закріпляти за собою водія для спостерігання за ним під час його поїздки.
     Детальна інформація щодо взаємодії з клієнтською частиною додатку зображено на діаграмі взаємодії (див. рис. 4.11).
     Таким чином за допомогою діаграм пакетів, компонентів та взаємодії було визначено основні технології та архітектуру проекту.
     Приклади коду клієнтської частини представлено у додатку Г.

Рисунок 4.10 – Діаграма компонентів клієнтської частини програмної системи «CareDrive»


Рисунок 4.11 – Діаграма взаємодії клієнтської частини програмної системи «CareDrive»
     .

5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
     5.1 Виклик і завантаження
     
     
     Для того щоб розпочати роботу з проектом, потрібно завантажити архів за шляхом «https://github.com/NureKrykukhaMaksym4/apz-pzpi-21-4-krykukha-maksym.git» та розархівувати його.
     Щоб запрацювала база даних потрібно завантажити останню версію СУБД PostgreSQL з офіційного сторінки виробника.
     Далі потрібно створити «.env» файл та записати в нього посилання на «DATABASE_URL» до бази даних.
     Після чого потрібно запустити серверну частину прописавши деякі команди в термінали середовища (потрібно спочатку перейти до кореня серверної частини проекту):
* npm init;
* npm prisma format;
* npm prisma migrate dev --preview-feature;
* npm run start:devю
     Після чого потрібно для запуску клієнтської частини потрібно створити також «.env» файл та записати в нього дані зображені на рисунку 5.1. 
     
     
     Рисунок 5.1 – Запис налаштувань для ініціалізації клієнтської частини системи «CareDrive»
     
     Далі можно запустити клієнтську частину за допомогою наступних команд:
* npm init;
* npm run dev.
     На останок потрібно завантажити Python з офіційної сторінки розробників  та перейти в будь-яке IDE, перейти до IoT частини проекту та запустити за допомогою команди:
* python ./CareDriveIot.py
     
     
     5.2 Призначення і логічна структура
     
     
     Основна логіка яку можна виділити з проекту та розбити на модулі це:
* авторизація та реєстрація;
* водії;
* слідкувачі;
* серцебиття;
* сповіщення;
* нещасні випадки;
* машини.
     Модуль авторизації та реєстрації дозволяє реєструватися та увійти в профіль водіям або спостерігачами . Для авторизації потрібно написати ім’я, прізвище, пошту та пароль. Для того щоб увійти як адміністратор потрібно авторизуватись за допомогою таких даних:
* ім’я - ADMIN
* прізвище - ADMIN
* пошта -test@gmail.com
* пароль  ADMIN
     Модулі водії та слідкувачі існують для того щоб була можливість переглядати, редагувати або видаляти інформацію щодо необхідної людини.
     Модуль серцебиття створений для того щоб преглядати, редагувати або видаляти записи серцебиття водія в певний час.
     Модуль сповіщення існує для того щоб створювати сповіщення відповідно до серцебиття водія під час поїздки, якщо серцебиття в зоні ризику (дуже велике або дуже низьке) то створюватиметься сповіщення яке можна переглядати, редагувати або видаляти зі всією потрібною інформацією.
     Модуль нещасні випадки існують для того щоб при незвичайному серцебитті водія записувати що саме спричинило серце водія битися частіше або навпаки почало сповільнюватися.
     Модуль машини існують для того щоб водій міг заносити до бази даних всю необхідну інформацію стосовно його автопарку, та була можливість переглядати редагувати та видаляти записи.
     
     
     5.3 Опис програмної реалізації
     
     
     При почату роботи клієнтської частини застосунку користувач бачить головну сторінку (див. рис. 5.2).
     

Рисунок 5.2 – Головна сторінка клієнтської частини системи «CareDrive»
     
     Далі користувач має декілька напрямків свого шляху використання застосунку, розпочнемо по порядку.
     Перший це змінити локалізацію, яка більше підходить для користувача (див. рис. 5.3).
     
     
     Рисунок 5.3 – Зміна локалізації застосунка системи «CareDrive»
     
     При обиранні відповідної мови застосунок буде перекладатися на мову, яку хоче бачити користувач.
     Далі після вибраної мови користувач має можливість авторизуватися (див. рис. 5.4) або зареєструватися (див. рис. 5.5-5.6), якщо він ще не має свого профіля на нашому продукті.
     
     
     Рисунок 5.4 – Авторизація користувача системи «CareDrive»
     
     
     Рисунок 5.5 -Перша сторінка реєстрації нового користувача системи «CareDrive»
     
     
     Рисунок 5.6 – Друга сторінка реєстрації нового користувача системи «CareDrive»
     
     Після вдалої авторизації або реєстрації користувач побачить в правому верхньому куті відповідну іконку профілю (див. рис. 5.7), яка свідчить про те, що користувач успішно увійшов до застосунку
     
     Рисунок 5.7 – Іконка успішно авторизованого користувача системи «CareDrive»
     
     Якщо користувач системи – адміністратор, з’явится панель адміністратора в лівому верхньому куті застосунку (див. рис. 5.8), адміністратор також може змінити язик системи якщо він хоче на українську (див. рис. 5.9).
     

Рисунок 5.8 – Головна сторінка адміністратора системи «CareDrive»


Рисунок 5.9 – Українська локалізація головної сторінки адміністратора системи «CareDrive»
     
     Адміністратор має можливість експортувати або імпортувати резервну копію базу даних (див. рис. 5.10-5.12).
     
     
     Рисунок 5.10 – Можливість імпортувати/експортувати базу даних системи «CareDrive»
     
     
     Рисунок 5.11 –Експорт бази даних системи «CareDrive»
     
     
     Рисунок 5.12 –Імпорт резервної копії бази даних системи «CareDrive»
     
     Адміністратор має можливість переглядати (див. рис. 5.13) доступну інформацію та за необхідністю редагувати натискаючи на відповідний малюнок (див. рис. 5.14) або видаляти дані натискаючи на відповідну іконку (див. рис. 5.15), які потрібно, для збереження даних потрібно натиснути на кнопку «Зберегти змінні» або англійською «Save changes» (див.рис. 5.16).
     

Рисунок 5.13 – Перегляд інформації в системі системи «CareDrive»


Рисунок 5.14 – Іконка для початку редагування даних системи «CareDrive»


Рисунок 5.15 – Іконка для видалення даних системи «CareDrive»


Рисунок 5.16 – Кнопка збереження зроблених змін у системі системи «CareDrive»
     Далі щоб продемонструвати інший шлях користувача, потрібно спочатку вийти з профіля адміністратора за допомогою кнопки «Logout» (див рис. 5.7). Та увійти як звичайний спостерігач за водіями.
     Змінення ролі нам відкриває нові можливості (див. рис. 5.17)
     
     
     Рисунок 5.17 – Можливості спостерігача за водіями системи «CareDrive»
     
     Розпочнемо зліва направо, спершу щоб спостерігати за якимось водієм потрібно його взяти під догляд в меню «Take driver» натиснувши на кнопку «Take driver» (див. рис. 5.18) або українською «Взяти водія» (див. рис. 5.19).

Рисунок 5.18 – Функціонал меню «Взяти водія» системи «CareDrive»


Рисунок 5.19 – Українська локалізація кнопки «Take driver» системи «CareDrive»

	Коли спостерігач взяв водія для спостерігання можна перейти до меню «Accident» (див. рис. 5.17). В цьому меню спостерігач бачить серцебиття водія в дану мить (див. рис. 5.20).


Рисунок 5.20 – Функціонал меню «Accident» системи «CareDrive»

     Якщо знизиться або підвищиться серцебиття водія за короткий час то спостерігач зрозуміє що водій в небезпеці та потрібно швидко реагувати, щоб спасти водія.
     Наостанок перейдемо до функціоналу меню «Driver status» (див. рис. 5.17).
     В цьому меню спостерігач бачить кожного водія та його середній тиск серцебиття за останній місяць (див. рис. 5.21), для того щоб краще зрозуміти за ким краще потрібно спостерігати, щоб не скоїлось ніякого ДТП під час поїздки.
     

     Рисунок 5.21 – Функціонал меню «Drirver status» системи «CareDrive»
.

ВИСНОВКИ


     За результатами виконання роботи було створено програмну систему для моніторингу стану водіїв під час поїздок.
     У процесі роботи було проведено аналіз предметної області, розроблено структуру бази даних, спроектовано архітектуру програмної системи, що включає модулі моніторингу та користувацького інтерфейсу, та реалізовано її за допомогою Python.
     Розроблена програмна система дозволяє в режимі реального часу відстежувати фізичний стан водіїв, зокрема серцебиття, та інші важливі показники здоров'я. Вона забезпечує своєчасне реагування на критичні зміни стану водія, що підвищує загальну безпеку дорожнього руху. Система включає функції реєстрації та авторизації користувачів, оновлення їхніх даних, та зберігання історії фізіологічних показників.
     Користувачі можуть налаштовувати параметри моніторингу відповідно до індивідуальних потреб, отримувати сповіщення про зміни у стані водія та переглядати дані в зручному форматі. Також система має можливості адміністрування, які включають управління користувачами, налаштування параметрів системи, і забезпечення безпеки даних через використання механізмів шифрування та аутентифікації.
     Таким чином, розроблена система є важливим інструментом для підвищення безпеки на дорогах через забезпечення постійного моніторингу фізичного стану водіїв.
     Посилання на youtube відео з захистом: https://youtu.be/JngjNe2guUQ 
     

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


     1. PostgreSQL 16.3 Documentation. PostgreSQL Documentation. URL: https://www.postgresql.org/docs/16/index.html (дата звернення: 01.06.2024).
     2.  Vite js documentation.  URL: https://vitejs.dev/guide// (дата звернення: 01.06.2024).
     3. React Reference Overview – React. URL: https://react.dev/reference/react (дата звернення: 01.06.2024).
     4. Design Patterns: Elements of Reusable Object-Oriented Software (Addison-Wesley Professional Computing Series) / R. Helm та ін. Addison-Wesley Professional, 1995. 395 р.
     5. Kamal R. Embedded Systems - Architecture, Programming and Design. Tata McGraw Hill, 2008.

ДОДАТОК А
Програмний код серверної частини
А.1 Знімок екрану перевірки плагіату:
     
     Рисунок А.1 – Знімок екрану перевірки плагіату
     
ДОДАТОК Б
Програмний код серверної частини
     Б.1 Код основного файлу для роботи сервера main.ts:
     
     
1. // Import necessary modules and services
 2. import { NestFactory } from '@nestjs/core';
 3. import { AppModule } from './app.module';
 4. import { PrismaService } from './prisma/prisma.service';
 5. import * as cookieParser from 'cookie-parser';
 6. import * as fs from 'fs';
 7. 
 8. // Async function to bootstrap the application
 9. async function bootstrap() {
10.   // Create a NestJS application instance
11.   const httpsOptions = {
12.     key: fs.readFileSync('./secrets/cert.key'),
13.     cert: fs.readFileSync('./secrets/cert.crt'),
14.   };
15.   const app = await NestFactory.create(AppModule, {
16.     httpsOptions,
17.   });
18.   
19.   // Enable Cross-Origin Resource Sharing (CORS) for the specified origin, methods, and credentials
20.   app.enableCors({
21.     origin: ['http://localhost:3000'],  // Allow requests from this origin
22.     methods: '*',  // Allow all HTTP methods
23.     credentials: true, // Allow credentials (cookies, authorization headers, etc.)
24.   });
25. 
26.   // Use the cookie-parser middleware to parse cookies in incoming requests
27.   app.use(cookieParser());
28. 
29.   // Get an instance of the PrismaService
30.   const prismaService = app.get(PrismaService);
31. 
32.   // Enable Prisma's shutdown hooks to properly close connections on shutdown
33.   await prismaService.enableShutdownHooks(app);
34. 
35.   // Start listening for incoming requests on port 3001
36.   await app.listen(3001);
37. }
38. 
39. // Call the bootstrap function to start the application
40. bootstrap();



     Б.2 Код сервісу спостерігача:
     
     
1. import { BadRequestException, ForbiddenException, Injectable } from '@nestjs/common';
2. import { PrismaService } from 'src/prisma/prisma.service';
3. import * as bcrypt from 'bcrypt';
4. import { WatcherLoginpDto } from 'src/api/auth/dto';
5. import * as EmailValidator from 'email-validator';
6. 
7. // Injectable decorator to make the service injectable
8. @Injectable()
9. export class WatcherService {
10.     constructor(private prisma:PrismaService){}
11. 
12.     // Function to get a watcher by email
13.     async getWatcher(email:string):Promise<any>{
14.         return this.prisma.watcher.findFirst({
15.             where: {
16.               email:email,
17.             },
18.           });
19.     }
20. 
21.     // Function to get all watchers
22.     async getWatchers(): Promise<any>{
23.         return this.prisma.watcher.findMany()
24.     }
25. 
26.     // Function to get a watcher by id
27.     async getById(id){
28.       return this.prisma.watcher.findFirst({
29.         where:{id:id}
30.       })
31.     } 
32. 
33.     // Function to update a watcher's details
34.     async updateWatcher(id:string,body){
35.       // Validate email using EmailValidator
36.       if (!EmailValidator.validate(body.email) ){
37.         throw new BadRequestException("Invalid email")
38.       }
39.       // Validate phone number format
40.       if (!/^\d{10}$/.test(body.phone)){
41.         throw new BadRequestException('Invalid phone number')
42.       }
43.       // Generate salt and hash the password
44.       const salt = await bcrypt.genSalt(10);
45.       const hashedPassword = await bcrypt.hash(body.password,salt)
46.       // Update watcher's details in the database
47.       const result = await this.prisma.watcher.update({
48.         where:{id:id},
49.         data: {
50.           email: body.email,
51.           watcherSurname:body.watcherSurname,
52.           phone: body.phone,
53.           password: hashedPassword,
54.           watcherName:body.watcherName
55.         }
56.       })
57.       return result
58.     }
59. 
60.     // Function to delete a watcher by id
61.     async deleteWatcher(id:string){
62.       await this.prisma.watcher.delete({where:{id}})
63.     }
64. }
     
     
     Б.3 Код контролеру для експорту та імпорту бази даних:
     
     
1. import { Body, Controller, Get, Post, Res, UploadedFile, UseGuards, UseInterceptors } from '@nestjs/common';
 2. import { FileInterceptor } from '@nestjs/platform-express';
 3. import { Response } from 'express';
 4. import { DatabaseService } from './database.service';
 5. import { AuthGuard } from '../auth/auth.guard';
 6. 
 7. // Controller decorator to define the controller
 8. @UseGuards(AuthGuard)
 9. @Controller('api/database')
10. export class DatabaseController {
11.     constructor(private readonly databaseService: DatabaseService){}
12. 
13.     // Handler for exporting data to Excel
14.     @Get('export')
15.     async exportToExcel(
16.       @Res() res: Response,
17.     ) {
18.       // Export data to Excel format
19.       const buffer = await this.databaseService.exportToExcel();
20.       // Set response headers for Excel file
21.       res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
22.       res.setHeader('Content-Disposition', 'attachment; filename=users.xlsx');
23.       // Send Excel file as response
24.       res.send(buffer);
25.     }
26. 
27.     // Handler for importing data from Excel
28.     @Post('import')
29.     @UseInterceptors(FileInterceptor('file'))
30.     async importFromExcel(@UploadedFile() file) {
31.       // Import data from Excel file buffer
32.       return await this.databaseService.importFromExcel(file.buffer);
33.     }
34. }
     
     
     Б.4 Код сервісу для серцебиття водія:
     
     
 1. import { ForbiddenException, Injectable } from '@nestjs/common';
 2. import { AddHeartbeatDto, UpdateHeartbeatDto } from './dto';
 3. import { PrismaService } from 'src/prisma/prisma.service';
 4. import { WatcherRole } from 'src/constants/enum';
 5. 
 6. // Injectable decorator to make the service injectable
 7. @Injectable()
 8. export class HeartbeatService {
 9. 
10.     constructor (private prisma: PrismaService){
11.     }
12. 
13.     // Function to get heartbeat description based on count
14.     async getHeartbeatDescription(count: number) {
15.         if (count < 60) {
16.           return "Low heartbeat";
17.         } else if (count >= 60 && count < 100) {
18.           return "Normal heartbeat";
19.         } else {
20.           return "High heartbeat";
21.         }
22.     }
23. 
24.     // Function to add a heartbeat
25.     async addHeartbeat(dto: AddHeartbeatDto){
26.         try{
27. 
28.             const admin = await this.prisma.watcher.findFirst({
29.                 where:{id:dto.watcherId}
30.             })
31.             const role = admin.role
32.         }
33.         catch (e){
34.             throw new ForbiddenException("You are not ADMIN")
35.         }
36.         const admin = await this.prisma.watcher.findFirst({
37.             where:{id:dto.watcherId}
38.         })
39.         if (!admin.role || admin.role !==WatcherRole.ADMIN ){
40.             throw new ForbiddenException("You are not ADMIN")
41.         }
42. 
43.         const desc = await this.getHeartbeatDescription(dto.count);
44.         const result = await this.prisma.heartbeat.create({
45.             data: {
46.                 count:dto.count,
47.                 description:desc,
48.                 driver:{connect:{id:dto.driverId}}
49.             }
50.         })
51. 
52.         const heartbeats = await this.prisma.heartbeat.findMany({
53.             where: {
54.               driverId: dto.driverId,
55.               createdAt: {
56.                 gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
57.                 lt: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1)
58.               }
59.             }
60.         });
61. 
62.         const averageCount = heartbeats.reduce((acc, heartbeat) => acc + heartbeat.count, 0) / heartbeats.length;
63. 
64.         return await this.prisma.driver.update({
65.             where:{
66.                 id:dto.driverId
67.             },data:{
68.                 averageMonthlyHeartbeat: Math.round(averageCount)
69.             }
70.         }) 
71.     }
72. 
73.     // Function to update a heartbeat
74.     async updateHeartbeat(id,dto: UpdateHeartbeatDto){
75. 
76.         const desc = await this.getHeartbeatDescription(dto.count);
77.         
78.         const result = await this.prisma.heartbeat.update({
79.             where:{
80.                 id:id
81.             },data:{
82.                 description:desc,
83.                 count:dto.count,
84.                 driver:{connect:{id:dto.driverId}}
85.             }
86.         })
87.         const heartbeats = await this.prisma.heartbeat.findMany({
88.             where: {
89.               driverId: dto.driverId,
90.               createdAt: {
91.                 gte: new Date(new Date().getFullYear(), new Date().getMonth(), 1),
92.                 lt: new Date(new Date().getFullYear(), new Date().getMonth() + 1, 1)
93.               }
94.             }
95.         });
96. 
97.         const averageCount = heartbeats.reduce((acc, heartbeat) => acc + heartbeat.count, 0) / heartbeats.length;
98. 
99.         const driver = await this.prisma.driver.update({
100.             where:{
101.                 id:dto.driverId
102.             },data:{
103.                 averageMonthlyHeartbeat: Math.round(averageCount)
104.             }
105.         }) 
106. 
107.         return result
108.     }
109. 
110.     // Function to get all heartbeats
111.     async getAllHeartbeats(){
112.         return this.prisma.heartbeat.findMany()
113.     }
114. 
115.     // Function to get a heartbeat by id
116.     async getHeartbeatById(id){
117.         return this.prisma.heartbeat.findFirst({
118.             where:{
119.                 id:id
120.             }
121.         })
122.     }
123. 
124.     // Function to delete a heartbeat by id
125.     async deleteHeartbeatById(id){
126.         await this.prisma.heartbeat.delete({
127.             where:{id:id}
128.         })
129.     }
130. 
131. }


ДОДАТОК В
Програмний код IoT пристрою
     В.1 Код основного модуля для роботи сервера CareDriveIot.py
     
     
 1. import Auth
 2. import Session
 3. import Heartbeat
 4. import iot
 5. 
 6. # Main function
 7. def main():
 8.     try:
 9.         # Create a new IoT device
10.         new_iot = iot.create_new_iot()
11. 
12.         # Get driver and watcher IDs
13.         DRIVER_ID = Auth.get_driver_id(new_iot)
14.         WATCHER_ID = Auth.get_watcher_id()
15. 
16.         # Create session ID and start sending heartbeats
17.         SESSION_ID = Session.create_session("testing", DRIVER_ID, WATCHER_ID)
18.         Heartbeat.send_heartbeats(SESSION_ID, WATCHER_ID, DRIVER_ID)
19. 
20.     except Exception as e:
21.         # End session in case of an exception
22.         Session.end_session(SESSION_ID)
23. 
24. # Execute main function if the script is run directly
25. if __name__ == "__main__":
26.     main()
     
     
     В.2 Код модуля Auth,py
     
     
 1. from datetime import datetime
 2. import requests
 3. import configuration
 4. 
 5. # Base URL for the API endpoint
 6. BASE_URL = configuration.get_base_url()
 7. # Headers for localization
 8. headers = {"localization": "uk",}
 9. 
10. # Function to authenticate the driver and return the response
11. def authenticate_driver(iot) -> str:
12.     url = f"{BASE_URL}/auth/driver_login"
13.     try:
14.         # Gather driver authentication data
15.         email = input("Enter your email: ")
16.         phone = input("Enter your phone: ")
17.         driverName = input("Enter your name: ")
18.         driverSurname = input("Enter your surname: ")
19.         password = input("Enter your password: ")
20. 
21.         # Authentication data for driver
22.         auth_data_driver = {}
23.         auth_data_driver["email"] = email
24.         auth_data_driver["phone"] = phone
25.         auth_data_driver["driverName"] = driverName
26.         auth_data_driver["driverSurname"] = driverSurname
27.         auth_data_driver["password"] = password
28.         # Send POST request for driver authentication
29.         response = requests.post(url, headers=headers, json=auth_data_driver)
30.     except Exception as e :
31.         print("Error at authentication")
32.     return(response)
33. 
34. # Get driver ID from authentication response
35. def get_driver_id(iot):
36.     response = authenticate_driver(iot)
37. 
38.     global driver_id
39.     driver_id = (response.json()['driver']['id'])
40.     print("Driver", driver_id)
41. 
42.     return driver_id
43. 
44. # Function to get not taken watchers
45. def get_not_taken_watchers():
46.     url = f'{BASE_URL}/watcher/not-taken'
47. 
48.     try:
49.         # Send GET request to get not taken watchers
50.         response = requests.get(url)
51.         # Return the ID of the not taken watcher
52.         return response.json()["id"]
53.     except Exception as e:
54.         print("Error occupied finding not taken Watcher")
55. 
56. # Function to get watcher ID after binding watcher to driver
57. def get_watcher_id():
58.     watcher_id = get_not_taken_watchers()
59. 
60.     data_binding_watcher_to_driver = {
61.         "watcherId" : watcher_id,
62.         "driverId" : driver_id
63.     }
64. 
65.     url = f'{BASE_URL}/driver/add-watcher'
66. 
67.     try:
68.         # Send POST request to bind watcher to driver
69.         response = requests.post(url,json=data_binding_watcher_to_driver)
70.         # Return the watcher ID
71.         return watcher_id
72.     except Exception as e:
73.         print("Error occupied at binding watcher")
     

ДОДАТОК Г
Програмний код клієнтської частини
     Г.1 Код основного сервісу для роботи сервера watcherService.ts
     
     
1. import axios from "axios";
2. import apiClient from "../config/apiClient";
3. import { UserInfoDto, WatcherInfoDto } from "../interfaces/interface";
4.
5. const getWatchers = async (
6.
7. ): Promise<UserInfoDto[]> => {
8.   try {
9.
10.     const response = await apiClient.get<UserInfoDto[]>(
11.       'api/watcher',
12.     );
13.     return response.data;
14.   } catch (error) {
15.     if (axios.isAxiosError(error)) {
16.       throw new Error(error.response?.data.message);
17.     } else {
18.       throw new Error("Unknown error occurred.");
19.     }
20.   }
21. };
22.
23. const updateWatcher = async (
24.   id?:string,
25.   email?:string,
26.   phone?:string,
27.   watcherName?:string,
28.   watcherSurname?:string,
29. ): Promise<WatcherInfoDto[]> => {
30.   const request = {email,phone,watcherName,watcherSurname}
31.   try {
32.
33.     const response = await apiClient.patch<WatcherInfoDto[]>(
34.       `api/watcher/${id}`,
35.       request
36.     );
37.     return response.data;
38.   } catch (error) {
39.     if (axios.isAxiosError(error)) {
40.       throw new Error(error.response?.data.message);
41.     } else {
42.       throw new Error("Unknown error occurred.");
43.     }
44.   }
45. };
46.
47. const watcherService = {
48.   getWatchers,
49.   updateWatcher
50. };
51.
52. export default watcherService;
     
     
     Г.2 Код сторінки Signup.tsx


1. import { Box, Button, Container, Paper, TextField, Typography } from "@mui/material";
2. import { useState } from 'react';
3. import { useTranslation } from "react-i18next";
4. import { Link, useNavigate } from "react-router-dom";
5. import authService from '../services/authService';
6. import useAuth from '../hooks/useAuth';
7. import { AuthResultDto, WatcherAuthResult, WatcherAuthResultDto } from '../interfaces/interface';
8. import { Roles, WatcherRoles } from '../interfaces/enums';
9.
10. const SignUp = () => {
11.   const { setAuth } = useAuth();
12.   const navigate = useNavigate();
13.   const { t } = useTranslation();
14.
15.   const [currentStep, setCurrentStep] = useState(1);
16.   const [role, setRole] = useState(WatcherRoles.None);
17.   const [watcherName, setWatcherName] = useState('');
18.   const [watcherSurname, setWatcherSurname] = useState('');
19.   const [phone, setPhone] = useState('');
20.   const [email, setEmail] = useState('');
21.   const [password, setPassword] = useState('');
22.
23.   const handleSignUp = async () => {
24.     try {
25.       let result: WatcherAuthResult = { id: '', role: '' };
26.       if (role === WatcherRoles.Watcher) {
27.         result = await authService.signUpWatcher(email, password, watcherName, watcherSurname, phone) as AuthResultDto
28.       }
29.
30.       setAuth(result);
31.       saveToLocalStorage(result.id, result.role, result.bearer);
32.       navigate("/");
33.     } catch (error) {
34.       console.error('Error');
35.     }
36.   };
37.
38.   const saveToLocalStorage = async (watcherId, role, bearer) => {
39.     localStorage.setItem('watcherId', watcherId!);
40.     localStorage.setItem('role', role!);
41.     localStorage.setItem('bearer', bearer!);
42.   }
43.
44.   const handleBack = () => {
45.     setCurrentStep(currentStep - 1);
46.   };
47.
48.   const handleNext = () => {
49.     setCurrentStep(currentStep + 1);
50.   };
51.
52.   const handleRoleSelection = (selectedRole: WatcherRoles) => {
53.     setRole(selectedRole);
54.     handleNext();
55.   };
56.
57.   const renderStep = () => {
58.     switch (currentStep) {
59.       case 1:
60.         return (
61.           <>
62.             <Typography variant="h5" gutterBottom align="center" mb={2}>
63.               {t("createAccount")}
64.             </Typography>
65.             <Box display="flex" justifyContent="center" flexDirection="column" gap="15px" mb={2} px={10}>
66.               <Button variant="contained" color="primary" onClick={() => handleRoleSelection(WatcherRoles.Watcher)}>
67.                 {t("watcher")}
68.               </Button>
69.             </Box>
70.             <Box display="flex" justifyContent="center" flexDirection="column" gap="15px" mb={3} px={10}>
71.               <Typography variant="h6" align="center">
72.                 {t("alreadyRegistered")}
73.               </Typography>
74.               <Button variant="contained" color="primary" component={Link} to="/login">
75.                 {t("logIn")}
76.               </Button>
77.             </Box>
78.           </>
79.         );
80.       case 2:
81.         return (
82.           <>
83.             <Typography variant="h5" gutterBottom align="center" mb={2}>
84.               {t("enterName")}
85.             </Typography>
86.             <Box display="flex" flexDirection="column" gap="15px" mb={3} px={3}>
87.               <TextField
88.                 label={t("watcherName")}
89.                 variant="outlined"
90.                 fullWidth
91.                 value={watcherName}
92.                 onChange={(e) => setWatcherName(e.target.value)}
93.               />
94.               <TextField
95.                 label={t("watcherSurname")}
96.                 variant="outlined"
97.                 fullWidth
98.                 value={watcherSurname}
99.                 onChange={(e) => setWatcherSurname(e.target.value)}
100.               />
101.               <TextField
102.                 label={t("phone")}
103.                 variant="outlined"
104.                 fullWidth
105.                 value={phone}
106.                 onChange={(e) => setPhone(e.target.value)}
107.               />
108.             </Box>
109.             <Box display="flex" justifyContent="space-between" flexDirection="row" mb={3} px={3}>
110.               <Button variant="outlined" color="primary" onClick={handleBack}>
111.                 {t("back")}
112.               </Button>
113.               <Button variant="contained" color="primary" onClick={handleNext}>
114.                 {t("next")}
115.               </Button>
116.             </Box>
117.           </>
118.         );
119.       case 3:
120.         return (
121.           <>
122.             <Typography variant="h5" gutterBottom align="center" mb={2}>
123.               {t("enterEmailAndPassword")}
124.             </Typography>
125.             <Box display="flex" flexDirection="column" gap="15px" mb={3} px={3}>
126.               <TextField
127.                 label={t("email")}
128.                 variant="outlined"
129.                 fullWidth
130.                 value={email}
131.                 onChange={(e) => setEmail(e.target.value)}
132.               />
133.               <TextField
134.                 label={t("password")}
135.                 variant="outlined"
136.                 fullWidth
137.                 type="password"
138.                 value={password}
139.                 onChange={(e) => setPassword(e.target.value)}
140.               />
141.             </Box>
142.             <Box display="flex" justifyContent="space-between" flexDirection="row" mb={3} px={3}>
143.               <Button variant="outlined" color="primary" onClick={handleBack}>
144.                 {t("back")}
145.               </Button>
146.               <Button variant="contained" color="primary" onClick={handleSignUp}>
147.                 {t("signUp")}
148.               </Button>
149.             </Box>
150.           </>
151.         );
152.       default:
153.         return null;
154.     }
155.   };
156.
157.   return (
158.     <Container maxWidth="xs">
159.       <Paper elevation={3} style={{ padding: '20px', marginTop: '50px' }}>
160.         {renderStep()}
161.       </Paper>
162.     </Container>
163.   );
164. };
165.
166. export default SignUp;


     Г.3 Код файлу AuthProvider.ts


1. import { createContext, useEffect, useState } from "react";
2. import { AuthResultDto, WatcherAuthResult } from "../interfaces/interface";
3.
4. interface AuthContextProps {
5.   auth: AuthResultDto;
6.   setAuth: React.Dispatch<React.SetStateAction<WatcherAuthResult>>;
7. }
8.
9. interface AuthProviderProps {
10.   children: React.ReactNode;
11. }
12.
13. const AuthContext = createContext({} as AuthContextProps);
14.
15. export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
16.   const [auth, setAuth] = useState<AuthResultDto>({});
17.
18.   useEffect(() => {
19.     const userId = localStorage.getItem("userId");
20.     const bearer = localStorage.getItem("accessToken");
21.     const role = localStorage.getItem("role");
22.
23.     if (!auth.userId && userId && bearer && role) {
24.       setAuth({ userId, bearer, role });
25.     }
26.   }, [auth.userId]);
27.
28.   return (
29.     <AuthContext.Provider value={{ auth, setAuth }}>
30.       {children}
31.     </AuthContext.Provider>
32.   );
33. }
34.
35. export default AuthContext;